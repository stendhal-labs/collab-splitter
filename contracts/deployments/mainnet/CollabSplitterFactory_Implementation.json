{
  "address": "0xcBC91bb56c60c9660CF7805be1043BdbC914aD97",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "splitter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "recipients",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "SplitterCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name_",
          "type": "string"
        },
        {
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        },
        {
          "internalType": "address[]",
          "name": "recipients",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "createSplitter",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSplitterImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "splitterImplementation",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner_",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "setSplitterImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9d3fd0448ba45c5d69dd8f325b4702492f1ee00962181ca861036171598f597c",
  "receipt": {
    "to": null,
    "from": "0x7C2fd19ae183407230f929794ce4d50ce6569b0c",
    "contractAddress": "0xcBC91bb56c60c9660CF7805be1043BdbC914aD97",
    "transactionIndex": 231,
    "gasUsed": "650859",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf9a40fe8771e97027543bd9dac0a2f7f12700009c078a97271a4e0acbc22941c",
    "transactionHash": "0x9d3fd0448ba45c5d69dd8f325b4702492f1ee00962181ca861036171598f597c",
    "logs": [],
    "blockNumber": 13745668,
    "cumulativeGasUsed": "28975523",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "60f67688df512955030de0b2c492b991",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"splitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"SplitterCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"createSplitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSplitterImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"splitterImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"setSplitterImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Simon Fremaux (@dievardump)\",\"kind\":\"dev\",\"methods\":{\"createSplitter(string,bytes32,address[],uint256[])\":{\"details\":\"the contract created is a minimal proxy to the _splitterImplementation      the list of recipients (and the corresponding amounts) should then be used in the exact same order      to create the merkleProof and merkleRoot\",\"params\":{\"amounts\":\"list of amounts\",\"merkleRoot\":\"merkle root of the tree of recipients\",\"name_\":\"name of the Splitter (for convenience)\",\"recipients\":\"list of recipients\"},\"returns\":{\"newContract\":\"the address of the new contract\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setSplitterImplementation(address)\":{\"params\":{\"implementation\":\"the address to proxy calls to\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"CollabSplitterFactory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createSplitter(string,bytes32,address[],uint256[])\":{\"notice\":\"Creates a new CollabSplitter contract\"},\"getSplitterImplementation()\":{\"notice\":\"Getter for the Splitter Implementation\"},\"setSplitterImplementation(address)\":{\"notice\":\"Setter for the Splitter Implementation\"}},\"notice\":\"This contract allows people to create a \\\"Splitter\\\" -> a contract that will         allow to split the ETH or ERC20 it received, between several addresses         This contract is upgradeable, because we might have to add functionalities         or versioning over time.         However, the Factory has no authority over a Splitter after it's created         which ensure that updates to the current contract         won't create any problems / exploits on existing Splitter\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CollabSplitterFactory.sol\":\"CollabSplitterFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x35b09b69aca3bc2633da8f47382a81ecf367efe57167a2114f60f9ec81988afa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xf4059b28b9d7c342804d33b16ea30c65ca6afd560e426b44ca727a0343c04c68\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x828a6fb02c79a63dc5867427f355c0a9c65b4359fecadae73883154da550f6f8\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\",\"keccak256\":\"0x3d82fc9292d8d34bc25d104ea743684ad7cc3997397b7284f8dcad0ae70155db\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\",\"keccak256\":\"0xa8eded8062871a4b146c437c8e0e5ba96b1fec87c9f303a461a727b3fd5856d9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"contracts/CollabSplitter.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title CollabSplitterFactory\\n/// @author Simon Fremaux (@dievardump)\\ncontract CollabSplitter is Initializable {\\n    event ETHClaimed(address operator, address account, uint256 amount);\\n    event ERC20Claimed(\\n        address operator,\\n        address account,\\n        uint256 amount,\\n        address token\\n    );\\n\\n    struct ERC20Data {\\n        uint256 totalReceived;\\n        uint256 lastBalance;\\n    }\\n\\n    // string public name;\\n    bytes32 public merkleRoot;\\n\\n    // keeps track of how much was received in ETH since the start\\n    uint256 public totalReceived;\\n\\n    // keeps track of how much an account already claimed ETH\\n    mapping(address => uint256) public alreadyClaimed;\\n\\n    // keeps track of ERC20 data\\n    mapping(address => ERC20Data) public erc20Data;\\n    // keeps track of how much an account already claimed for a given ERC20\\n    mapping(address => mapping(address => uint256)) private erc20AlreadyClaimed;\\n\\n    function initialize(bytes32 merkleRoot_) external initializer {\\n        merkleRoot = merkleRoot_;\\n    }\\n\\n    receive() external payable {\\n        totalReceived += msg.value;\\n    }\\n\\n    /// @notice Does claimETH and claimERC20 in one call\\n    /// @param account the account we want to claim for\\n    /// @param percent the allocation for this account | 2 decimal basis, meaning 1 = 100, 2.5 = 250 etc...\\n    /// @param merkleProof the merkle proof used to ensure this claim is legit\\n    /// @param erc20s the ERC20 contracts addresses to claim from\\n    function claimBatch(\\n        address account,\\n        uint256 percent,\\n        bytes32[] memory merkleProof,\\n        address[] memory erc20s\\n    ) public {\\n        require(\\n            MerkleProofUpgradeable.verify(\\n                merkleProof,\\n                merkleRoot,\\n                getNode(account, percent)\\n            ),\\n            'Invalid proof.'\\n        );\\n\\n        _claimETH(account, percent);\\n\\n        for (uint256 i; i < erc20s.length; i++) {\\n            _claimERC20(account, percent, erc20s[i]);\\n        }\\n    }\\n\\n    /// @notice Allows to claim the ETH for an account\\n    /// @param account the account we want to claim for\\n    /// @param percent the allocation for this account | 2 decimal basis, meaning 1 = 100, 2.5 = 250 etc...\\n    /// @param merkleProof the merkle proof used to ensure this claim is legit\\n    function claimETH(\\n        address account,\\n        uint256 percent,\\n        bytes32[] memory merkleProof\\n    ) public {\\n        require(\\n            MerkleProofUpgradeable.verify(\\n                merkleProof,\\n                merkleRoot,\\n                getNode(account, percent)\\n            ),\\n            'Invalid proof.'\\n        );\\n\\n        _claimETH(account, percent);\\n    }\\n\\n    /// @notice Allows to claim an ERC20 for an account\\n    /// @dev To be able to do so, every time a claim is asked, we will compare both current and last known\\n    ///      balance for this contract, allowing to keep up to date on how much it has ever received\\n    ///      then we can calculate the full amount due to the account, and substract the amount already claimed\\n    /// @param account the account we want to claim for\\n    /// @param percent the allocation for this account | 2 decimal basis, meaning 1% = 100, 2.5% = 250 etc...\\n    /// @param merkleProof the merkle proof used to ensure this claim is legit\\n    /// @param erc20s the ERC20 contracts addresses to claim from\\n    function claimERC20(\\n        address account,\\n        uint256 percent,\\n        bytes32[] memory merkleProof,\\n        address[] memory erc20s\\n    ) public {\\n        require(\\n            MerkleProofUpgradeable.verify(\\n                merkleProof,\\n                merkleRoot,\\n                getNode(account, percent)\\n            ),\\n            'Invalid proof.'\\n        );\\n\\n        for (uint256 i; i < erc20s.length; i++) {\\n            _claimERC20(account, percent, erc20s[i]);\\n        }\\n    }\\n\\n    /// @notice Function to create the \\\"node\\\" in the merkle tree, given account and allocation\\n    /// @param account the account\\n    /// @param percent the allocation\\n    /// @return the bytes32 representing the node / leaf\\n    function getNode(address account, uint256 percent)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(account, percent));\\n    }\\n\\n    /// @notice Helper allowing to know how much ETH is still claimable for a list of accounts\\n    /// @param accounts the account to check for\\n    /// @param percents the allocation for this account\\n    function getBatchClaimableETH(\\n        address[] memory accounts,\\n        uint256[] memory percents\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory claimable = new uint256[](accounts.length);\\n        for (uint256 i; i < accounts.length; i++) {\\n            claimable[i] = _calculateDue(\\n                totalReceived,\\n                percents[i],\\n                alreadyClaimed[accounts[i]]\\n            );\\n        }\\n        return claimable;\\n    }\\n\\n    /// @notice Helper allowing to know how much of an ERC20 is still claimable for a list of accounts\\n    /// @param accounts the account to check for\\n    /// @param percents the allocation for this account\\n    /// @param token the token (ERC20 contract) to check on\\n    function getBatchClaimableERC20(\\n        address[] memory accounts,\\n        uint256[] memory percents,\\n        address token\\n    ) public view returns (uint256[] memory) {\\n        ERC20Data memory data = erc20Data[token];\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 sinceLast = balance - data.lastBalance;\\n\\n        // the difference between last claim and today's balance is what has been received as royalties\\n        // so we can add it to the total received\\n        data.totalReceived += sinceLast;\\n\\n        uint256[] memory claimable = new uint256[](accounts.length);\\n        for (uint256 i; i < accounts.length; i++) {\\n            claimable[i] = _calculateDue(\\n                data.totalReceived,\\n                percents[i],\\n                erc20AlreadyClaimed[accounts[i]][token]\\n            );\\n        }\\n\\n        return claimable;\\n    }\\n\\n    /// @notice Helper to query how much an account already claimed for a list of tokens\\n    /// @param account the account to check for\\n    /// @param tokens the tokens addresses\\n    ///        use address(0) to query for nativ chain token\\n    function getBatchClaimed(address account, address[] memory tokens)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory claimed = new uint256[](tokens.length);\\n        for (uint256 i; i < tokens.length; i++) {\\n            if (tokens[i] == address(0)) {\\n                claimed[i] = alreadyClaimed[account];\\n            } else {\\n                claimed[i] = erc20AlreadyClaimed[account][tokens[i]];\\n            }\\n        }\\n\\n        return claimed;\\n    }\\n\\n    /// @dev internal function to claim ETH\\n    /// @param account the account we want to claim for\\n    /// @param percent the allocation for this account | 2 decimal basis, meaning 1% = 100, 2.5% = 250 etc...\\n    function _claimETH(address account, uint256 percent) internal {\\n        if (totalReceived == 0) return;\\n\\n        uint256 dueNow = _calculateDue(\\n            totalReceived,\\n            percent,\\n            alreadyClaimed[account]\\n        );\\n\\n        if (dueNow == 0) return;\\n\\n        // update the already claimed first, blocking reEntrancy\\n        alreadyClaimed[account] += dueNow;\\n\\n        // send the due;\\n        // @TODO: .call{}() calls with all gas left in the tx\\n        // Question: Should we limit the gas used here?!\\n        // It has to be at least enough for contracts (Gnosis etc...) to proxy and store\\n        (bool success, ) = account.call{value: dueNow}('');\\n        require(success, 'Error when sending ETH');\\n\\n        emit ETHClaimed(msg.sender, account, dueNow);\\n    }\\n\\n    /// @dev internal function to claim an ERC20\\n    /// @param account the account we want to claim for\\n    /// @param percent the allocation for this account | 2 decimal basis, meaning 1% = 100, 2.5% = 250 etc...\\n    /// @param erc20 the ERC20 contract to claim from\\n    function _claimERC20(\\n        address account,\\n        uint256 percent,\\n        address erc20\\n    ) internal {\\n        ERC20Data storage data = erc20Data[erc20];\\n        uint256 balance = IERC20(erc20).balanceOf(address(this));\\n        uint256 sinceLast = balance - data.lastBalance;\\n\\n        // the difference between last known balance and today's balance is what has been received as royalties\\n        // so we can add it to the total received\\n        data.totalReceived += sinceLast;\\n\\n        // now we can calculate how much is due to current account the same way we do for ETH\\n        if (data.totalReceived == 0) return;\\n\\n        uint256 dueNow = _calculateDue(\\n            data.totalReceived,\\n            percent,\\n            erc20AlreadyClaimed[account][erc20]\\n        );\\n\\n        if (dueNow == 0) return;\\n\\n        // update the already claimed first\\n        erc20AlreadyClaimed[account][erc20] += dueNow;\\n\\n        // transfer the dueNow\\n        require(\\n            IERC20(erc20).transfer(account, dueNow),\\n            'Error when sending ERC20'\\n        );\\n\\n        // update the lastBalance, so we can recalculate next time\\n        // we could save this call by doing (balance - dueNow) but some ERC20 might have weird behavior\\n        // and actually make the balance different than this after the transfer\\n        // so for safety, reading the actual state again\\n        data.lastBalance = IERC20(erc20).balanceOf(address(this));\\n\\n        // emitting an event will allow to identify claimable ERC20 in TheGraph\\n        // to be able to display them in the UI and keep stats\\n        emit ERC20Claimed(msg.sender, account, dueNow, erc20);\\n    }\\n\\n    /// @dev Helpers that calculates how much is still left to claim\\n    /// @param total total received\\n    /// @param percent allocation\\n    /// @param claimed what was already claimed\\n    /// @return what is left to claim\\n    function _calculateDue(\\n        uint256 total,\\n        uint256 percent,\\n        uint256 claimed\\n    ) internal pure returns (uint256) {\\n        return (total * percent) / 10000 - claimed;\\n    }\\n}\\n\",\"keccak256\":\"0x5f51d0f71bbdbe1f398d771429a348510ef1f0f9aef283669477c8a92a04e847\",\"license\":\"MIT\"},\"contracts/CollabSplitterFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\n\\nimport './CollabSplitterFactory/CollabSplitterFactoryStorage.sol';\\nimport './CollabSplitter.sol';\\n\\n/// @title CollabSplitterFactory\\n/// @author Simon Fremaux (@dievardump)\\n/// @notice This contract allows people to create a \\\"Splitter\\\" -> a contract that will\\n///         allow to split the ETH or ERC20 it received, between several addresses\\n///         This contract is upgradeable, because we might have to add functionalities\\n///         or versioning over time.\\n///         However, the Factory has no authority over a Splitter after it's created\\n///         which ensure that updates to the current contract\\n///         won't create any problems / exploits on existing Splitter\\ncontract CollabSplitterFactory is\\n    OwnableUpgradeable,\\n    CollabSplitterFactoryStorage\\n{\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    // emitted when a splitter contract is created\\n    event SplitterCreated(\\n        address indexed splitter,\\n        string name,\\n        address[] recipients,\\n        uint256[] amounts\\n    );\\n\\n    constructor() {}\\n\\n    function initialize(address splitterImplementation, address owner_)\\n        external\\n        initializer\\n    {\\n        _setSplitterImplementation(splitterImplementation);\\n\\n        if (owner_ != address(0)) {\\n            transferOwnership(owner_);\\n        }\\n    }\\n\\n    /// @notice Getter for the Splitter Implementation\\n    function getSplitterImplementation() public view returns (address) {\\n        return _splitterImplementation;\\n    }\\n\\n    /// @notice Creates a new CollabSplitter contract\\n    /// @dev the contract created is a minimal proxy to the _splitterImplementation\\n    ///      the list of recipients (and the corresponding amounts) should then be used in the exact same order\\n    ///      to create the merkleProof and merkleRoot\\n    /// @param name_ name of the Splitter (for convenience)\\n    /// @param merkleRoot merkle root of the tree of recipients\\n    /// @param recipients list of recipients\\n    /// @param amounts list of amounts\\n    /// @return newContract the address of the new contract\\n    function createSplitter(\\n        string memory name_,\\n        bytes32 merkleRoot,\\n        address[] memory recipients,\\n        uint256[] memory amounts\\n    ) external payable returns (address newContract) {\\n        require(_splitterImplementation != address(0), '!NO_IMPLEMENTATION!');\\n\\n        require(recipients.length == amounts.length, '!LENGTH_MISMATCH!');\\n\\n        uint256 total;\\n        for (uint256 i; i < amounts.length; i++) {\\n            require(amounts[i] != 0, '!NO_NULL_VALUE!');\\n            total += amounts[i];\\n        }\\n\\n        require(total == 10000, '!VALUE_MUST_BE_100!');\\n\\n        // create minimal proxy to _splitterImplementation\\n        newContract = ClonesUpgradeable.clone(_splitterImplementation);\\n\\n        // initialize the non upgradeable proxy\\n        CollabSplitter(payable(newContract)).initialize(merkleRoot);\\n\\n        // emit an event with all the data needed to reconstruct later the merkle tree\\n        // and allow people to claim their eth / tokens\\n        // using events will allow to store everything in TheGraph (or similar) in a decentralized way\\n        // while still be less expensive than storing in the CollabSplitter storage\\n        emit SplitterCreated(newContract, name_, recipients, amounts);\\n    }\\n\\n    /// @notice Setter for the Splitter Implementation\\n    /// @param implementation the address to proxy calls to\\n    function setSplitterImplementation(address implementation)\\n        public\\n        onlyOwner\\n    {\\n        _setSplitterImplementation(implementation);\\n    }\\n\\n    /// @dev internal setter for the Splitter Implementation\\n    /// @param implementation the address to proxy calls to\\n    function _setSplitterImplementation(address implementation) internal {\\n        _splitterImplementation = implementation;\\n    }\\n}\\n\",\"keccak256\":\"0xc9ae59785b31cf9193a3733355ccfe9dd876a795a80a8613ca799ea561147875\",\"license\":\"MIT\"},\"contracts/CollabSplitterFactory/CollabSplitterFactoryStorage.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol';\\n\\n/// @title CollabSplitterFactoryStorage\\n/// @author Simon Fremaux (@dievardump)\\ncontract CollabSplitterFactoryStorage {\\n    // current Splitter implementation\\n    address internal _splitterImplementation;\\n\\n    // gap\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xf2e9623bc08872b2f448981e8af4904cb0526f8bad113b9a75a901c7c9beb64a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610ad0806100206000396000f3fe6080604052600436106100705760003560e01c80638da5cb5b1161004e5780638da5cb5b146100db578063d76061c8146100f9578063dae2990614610119578063f2fde38b1461013757600080fd5b80632a8eee7714610075578063485cc955146100a4578063715018a6146100c6575b600080fd5b6100886100833660046107d6565b610157565b6040516001600160a01b03909116815260200160405180910390f35b3480156100b057600080fd5b506100c46100bf3660046108bc565b61039c565b005b3480156100d257600080fd5b506100c4610472565b3480156100e757600080fd5b506033546001600160a01b0316610088565b34801561010557600080fd5b506100c46101143660046108ef565b6104a8565b34801561012557600080fd5b506065546001600160a01b0316610088565b34801561014357600080fd5b506100c46101523660046108ef565b6104de565b6065546000906001600160a01b03166101ad5760405162461bcd60e51b8152602060048201526013602482015272214e4f5f494d504c454d454e544154494f4e2160681b60448201526064015b60405180910390fd5b81518351146101f25760405162461bcd60e51b8152602060048201526011602482015270214c454e4754485f4d49534d415443482160781b60448201526064016101a4565b6000805b83518110156102945783818151811061021157610211610911565b60200260200101516000141561025b5760405162461bcd60e51b815260206004820152600f60248201526e214e4f5f4e554c4c5f56414c55452160881b60448201526064016101a4565b83818151811061026d5761026d610911565b602002602001015182610280919061093d565b91508061028c81610955565b9150506101f6565b5080612710146102dc5760405162461bcd60e51b81526020600482015260136024820152722156414c55455f4d5553545f42455f3130302160681b60448201526064016101a4565b6065546102f1906001600160a01b0316610576565b604051639498bd7160e01b8152600481018790529092506001600160a01b03831690639498bd7190602401600060405180830381600087803b15801561033657600080fd5b505af115801561034a573d6000803e3d6000fd5b50505050816001600160a01b03167f1abfe31ad300b4944aba025be8e3da75652af4e833a11c0d86d6634a2b33c47587868660405161038b939291906109e4565b60405180910390a250949350505050565b600054610100900460ff16806103b5575060005460ff16155b6104185760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016101a4565b600054610100900460ff1615801561043a576000805461ffff19166101011790555b61044383610613565b6001600160a01b0382161561045b5761045b826104de565b801561046d576000805461ff00191690555b505050565b6033546001600160a01b0316331461049c5760405162461bcd60e51b81526004016101a490610a65565b6104a66000610635565b565b6033546001600160a01b031633146104d25760405162461bcd60e51b81526004016101a490610a65565b6104db81610613565b50565b6033546001600160a01b031633146105085760405162461bcd60e51b81526004016101a490610a65565b6001600160a01b03811661056d5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016101a4565b6104db81610635565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b03811661060e5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016101a4565b919050565b606580546001600160a01b0319166001600160a01b0392909216919091179055565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156106c6576106c6610687565b604052919050565b600067ffffffffffffffff8211156106e8576106e8610687565b5060051b60200190565b80356001600160a01b038116811461060e57600080fd5b600082601f83011261071a57600080fd5b8135602061072f61072a836106ce565b61069d565b82815260059290921b8401810191818101908684111561074e57600080fd5b8286015b8481101561077057610763816106f2565b8352918301918301610752565b509695505050505050565b600082601f83011261078c57600080fd5b8135602061079c61072a836106ce565b82815260059290921b840181019181810190868411156107bb57600080fd5b8286015b8481101561077057803583529183019183016107bf565b600080600080608085870312156107ec57600080fd5b843567ffffffffffffffff8082111561080457600080fd5b818701915087601f83011261081857600080fd5b813560208282111561082c5761082c610687565b61083e601f8301601f1916820161069d565b8281528a8284870101111561085257600080fd5b828286018383013760009281018201929092529096508701359450604087013591508082111561088157600080fd5b61088d88838901610709565b935060608701359150808211156108a357600080fd5b506108b08782880161077b565b91505092959194509250565b600080604083850312156108cf57600080fd5b6108d8836106f2565b91506108e6602084016106f2565b90509250929050565b60006020828403121561090157600080fd5b61090a826106f2565b9392505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000821982111561095057610950610927565b500190565b600060001982141561096957610969610927565b5060010190565b600081518084526020808501945080840160005b838110156109a95781516001600160a01b031687529582019590820190600101610984565b509495945050505050565b600081518084526020808501945080840160005b838110156109a9578151875295820195908201906001016109c8565b606081526000845180606084015260005b81811015610a1257602081880181015160808684010152016109f5565b81811115610a24576000608083860101525b50601f01601f1916820182810360809081016020850152610a4790820186610970565b90508281036040840152610a5b81856109b4565b9695505050505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260408201526060019056fea264697066735822122016a23c28b71b89fb1f07c6cbf1b96c8908a25925199d94b2f006e0fc865ee39e64736f6c63430008090033",
  "deployedBytecode": "0x6080604052600436106100705760003560e01c80638da5cb5b1161004e5780638da5cb5b146100db578063d76061c8146100f9578063dae2990614610119578063f2fde38b1461013757600080fd5b80632a8eee7714610075578063485cc955146100a4578063715018a6146100c6575b600080fd5b6100886100833660046107d6565b610157565b6040516001600160a01b03909116815260200160405180910390f35b3480156100b057600080fd5b506100c46100bf3660046108bc565b61039c565b005b3480156100d257600080fd5b506100c4610472565b3480156100e757600080fd5b506033546001600160a01b0316610088565b34801561010557600080fd5b506100c46101143660046108ef565b6104a8565b34801561012557600080fd5b506065546001600160a01b0316610088565b34801561014357600080fd5b506100c46101523660046108ef565b6104de565b6065546000906001600160a01b03166101ad5760405162461bcd60e51b8152602060048201526013602482015272214e4f5f494d504c454d454e544154494f4e2160681b60448201526064015b60405180910390fd5b81518351146101f25760405162461bcd60e51b8152602060048201526011602482015270214c454e4754485f4d49534d415443482160781b60448201526064016101a4565b6000805b83518110156102945783818151811061021157610211610911565b60200260200101516000141561025b5760405162461bcd60e51b815260206004820152600f60248201526e214e4f5f4e554c4c5f56414c55452160881b60448201526064016101a4565b83818151811061026d5761026d610911565b602002602001015182610280919061093d565b91508061028c81610955565b9150506101f6565b5080612710146102dc5760405162461bcd60e51b81526020600482015260136024820152722156414c55455f4d5553545f42455f3130302160681b60448201526064016101a4565b6065546102f1906001600160a01b0316610576565b604051639498bd7160e01b8152600481018790529092506001600160a01b03831690639498bd7190602401600060405180830381600087803b15801561033657600080fd5b505af115801561034a573d6000803e3d6000fd5b50505050816001600160a01b03167f1abfe31ad300b4944aba025be8e3da75652af4e833a11c0d86d6634a2b33c47587868660405161038b939291906109e4565b60405180910390a250949350505050565b600054610100900460ff16806103b5575060005460ff16155b6104185760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016101a4565b600054610100900460ff1615801561043a576000805461ffff19166101011790555b61044383610613565b6001600160a01b0382161561045b5761045b826104de565b801561046d576000805461ff00191690555b505050565b6033546001600160a01b0316331461049c5760405162461bcd60e51b81526004016101a490610a65565b6104a66000610635565b565b6033546001600160a01b031633146104d25760405162461bcd60e51b81526004016101a490610a65565b6104db81610613565b50565b6033546001600160a01b031633146105085760405162461bcd60e51b81526004016101a490610a65565b6001600160a01b03811661056d5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016101a4565b6104db81610635565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b03811661060e5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016101a4565b919050565b606580546001600160a01b0319166001600160a01b0392909216919091179055565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156106c6576106c6610687565b604052919050565b600067ffffffffffffffff8211156106e8576106e8610687565b5060051b60200190565b80356001600160a01b038116811461060e57600080fd5b600082601f83011261071a57600080fd5b8135602061072f61072a836106ce565b61069d565b82815260059290921b8401810191818101908684111561074e57600080fd5b8286015b8481101561077057610763816106f2565b8352918301918301610752565b509695505050505050565b600082601f83011261078c57600080fd5b8135602061079c61072a836106ce565b82815260059290921b840181019181810190868411156107bb57600080fd5b8286015b8481101561077057803583529183019183016107bf565b600080600080608085870312156107ec57600080fd5b843567ffffffffffffffff8082111561080457600080fd5b818701915087601f83011261081857600080fd5b813560208282111561082c5761082c610687565b61083e601f8301601f1916820161069d565b8281528a8284870101111561085257600080fd5b828286018383013760009281018201929092529096508701359450604087013591508082111561088157600080fd5b61088d88838901610709565b935060608701359150808211156108a357600080fd5b506108b08782880161077b565b91505092959194509250565b600080604083850312156108cf57600080fd5b6108d8836106f2565b91506108e6602084016106f2565b90509250929050565b60006020828403121561090157600080fd5b61090a826106f2565b9392505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000821982111561095057610950610927565b500190565b600060001982141561096957610969610927565b5060010190565b600081518084526020808501945080840160005b838110156109a95781516001600160a01b031687529582019590820190600101610984565b509495945050505050565b600081518084526020808501945080840160005b838110156109a9578151875295820195908201906001016109c8565b606081526000845180606084015260005b81811015610a1257602081880181015160808684010152016109f5565b81811115610a24576000608083860101525b50601f01601f1916820182810360809081016020850152610a4790820186610970565b90508281036040840152610a5b81856109b4565b9695505050505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260408201526060019056fea264697066735822122016a23c28b71b89fb1f07c6cbf1b96c8908a25925199d94b2f006e0fc865ee39e64736f6c63430008090033",
  "devdoc": {
    "author": "Simon Fremaux (@dievardump)",
    "kind": "dev",
    "methods": {
      "createSplitter(string,bytes32,address[],uint256[])": {
        "details": "the contract created is a minimal proxy to the _splitterImplementation      the list of recipients (and the corresponding amounts) should then be used in the exact same order      to create the merkleProof and merkleRoot",
        "params": {
          "amounts": "list of amounts",
          "merkleRoot": "merkle root of the tree of recipients",
          "name_": "name of the Splitter (for convenience)",
          "recipients": "list of recipients"
        },
        "returns": {
          "newContract": "the address of the new contract"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setSplitterImplementation(address)": {
        "params": {
          "implementation": "the address to proxy calls to"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "CollabSplitterFactory",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createSplitter(string,bytes32,address[],uint256[])": {
        "notice": "Creates a new CollabSplitter contract"
      },
      "getSplitterImplementation()": {
        "notice": "Getter for the Splitter Implementation"
      },
      "setSplitterImplementation(address)": {
        "notice": "Setter for the Splitter Implementation"
      }
    },
    "notice": "This contract allows people to create a \"Splitter\" -> a contract that will         allow to split the ETH or ERC20 it received, between several addresses         This contract is upgradeable, because we might have to add functionalities         or versioning over time.         However, the Factory has no authority over a Splitter after it's created         which ensure that updates to the current contract         won't create any problems / exploits on existing Splitter",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 210,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 213,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 292,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 10,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 123,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 2364,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "_splitterImplementation",
        "offset": 0,
        "slot": "101",
        "type": "t_address"
      },
      {
        "astId": 2368,
        "contract": "contracts/CollabSplitterFactory.sol:CollabSplitterFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)50_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}